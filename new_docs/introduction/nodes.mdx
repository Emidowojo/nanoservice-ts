---
title: Nodes
---

# Nodes in Nanoservice-ts

Nodes are the fundamental building blocks in the Nanoservice-ts architecture. Each Node is a self-contained, reusable unit of code designed to perform a single, specific, and well-defined task. Think of them as highly specialized microservices or serverless functions, but even more granular â€“ nanoservices.

## What is a Node?

A Node encapsulates a piece of logic that can be part of a larger [Workflow](./workflows.mdx). Examples of tasks a Node might perform include:

*   Making an HTTP request to an external API.
*   Querying a database.
*   Transforming data from one format to another.
*   Sending an email or a notification.
*   Performing a calculation.
*   Logging information.
*   Interacting with a file system.
*   Implementing custom business logic specific to your application.

Nodes are designed with the Single Responsibility Principle (SRP) in mind. This focus on a single task makes them:

*   **Easy to understand and maintain**: The scope of each Node is small.
*   **Highly reusable**: A Node written for one workflow can often be used in many others.
*   **Independently testable**: You can test the functionality of each Node in isolation.
*   **Scalable**: If a particular task becomes a bottleneck, the underlying infrastructure (if designed for it) could potentially scale instances of that Node type.

## Node Structure

A Nanoservice-ts Node typically consists of two main parts:

1.  **Node Definition (`node.json`)**: A JSON file that describes the Node's metadata, including its name, version, description, and importantly, its input and output schemas.
    *   **`name`**: A unique identifier for the Node type (e.g., `Http.Request`, `Database.QueryMongo`).
    *   **`description`**: A human-readable description of what the Node does.
    *   **`inputSchema`**: A JSON schema defining the expected input data structure and types for the Node. This allows for validation and clear contracts.
    *   **`outputSchema`**: A JSON schema defining the structure and types of data the Node will output upon successful execution.

2.  **Node Implementation (e.g., `index.ts`)**: A TypeScript file (or JavaScript) containing the actual logic that the Node executes. This file typically exports a class or function that conforms to the Nanoservice-ts Node interface.
    The implementation will receive input data (conforming to `inputSchema`), perform its task, and then either return output data (conforming to `outputSchema`) or signal an error.

### Example: `node.json` for a Simple Logger Node

```json
{
  "name": "Utils.Logger",
  "version": "1.0.0",
  "description": "Logs a message to the console.",
  "inputSchema": {
    "type": "object",
    "properties": {
      "message": {
        "type": "string",
        "description": "The message to log."
      },
      "level": {
        "type": "string",
        "enum": ["info", "warn", "error"],
        "default": "info",
        "description": "The log level."
      }
    },
    "required": ["message"]
  },
  "outputSchema": {
    "type": "object",
    "properties": {
      "status": {
        "type": "string",
        "enum": ["success"]
      }
    }
  }
}
```

### Example: `index.ts` for a Simple Logger Node (Conceptual)

```typescript
import { NanoserviceNode, NodeInput, NodeOutput, Context } from 'nanoservice-ts-sdk'; // Hypothetical SDK import

interface LoggerInput {
  message: string;
  level?: 'info' | 'warn' | 'error';
}

interface LoggerOutput {
  status: 'success';
}

export class LoggerNode implements NanoserviceNode<LoggerInput, LoggerOutput> {
  async execute(input: NodeInput<LoggerInput>, context: Context): Promise<NodeOutput<LoggerOutput>> {
    const { message, level = 'info' } = input.data;

    // Access shared context data if needed
    // const tenantId = context.get('tenantId');

    console[level](`[${context.workflowInstanceId || 'N/A'}] ${message}`);

    // Example of setting data back to context
    // context.set('lastLogTime', new Date().toISOString());

    return {
      data: { status: 'success' },
      // nextNodeId can also be determined dynamically here if the node supports it
    };
  }
}

// Or, for simpler nodes, it might be a function:
// export async function execute(input: NodeInput<LoggerInput>, context: Context): Promise<NodeOutput<LoggerOutput>> { ... }
```
*(Note: The exact SDK and class structure might vary. Refer to the official Nanoservice-ts SDK documentation for precise implementation details.)*

## Using Nodes in Workflows

In a Workflow definition, you instantiate Nodes by referencing their `name`. You provide the necessary input data, often mapping it from the trigger, the [Context Object](./context.mdx), or the output of previous Nodes.

```json
// ... inside a workflow definition ...
"nodes": [
  {
    "id": "log_start",
    "node": "Utils.Logger", // Referencing the Node by its name
    "input": {
      "message": "Workflow processing started for item: {{trigger.body.itemId}}",
      "level": "info"
    },
    "next_node_id": "process_item"
  },
  // ... other nodes ...
]
// ...
```

## Core Nodes vs. Custom Nodes

Nanoservice-ts typically provides a set of **core Nodes** for common tasks (e.g., HTTP requests, basic utilities, conditional logic). However, the real power comes from your ability to create **custom Nodes** tailored to your application's specific needs.

## Creating Custom Nodes

You can easily create your own Nodes using the `nanoctl` CLI:

```bash
nanoctl create node <node-name>
```

This command will scaffold the necessary files (`node.json` and `index.ts` or similar) in your project's `nodes/` directory, allowing you to define its schema and implement its logic.

Nodes are the heart of Nanoservice-ts, enabling modularity, reusability, and clarity in your backend applications. By mastering Node creation and usage, you can build sophisticated and maintainable systems.

Next, understand how data is shared and managed within a workflow execution: [Context Object](./context.mdx).
