---
title: Workflows
---

# Workflows in Nanoservice-ts

A Workflow in Nanoservice-ts is a fundamental concept representing a sequence or graph of interconnected [Nodes](./nodes.mdx) that collectively achieve a specific piece of business logic. Workflows define how data flows between Nodes and the precise order of their execution. They are the backbone of your application, orchestrating individual nanoservices (Nodes) to perform complex tasks.

## What is a Workflow?

Think of a Workflow as a recipe:

*   **Ingredients are your Nodes**: Each Node performs a small, specific action (e.g., fetch user data, send an email, update a record).
*   **The recipe instructions are your Workflow definition**: It dictates which Nodes to use, in what order, and how data (like intermediate results) is passed from one Node to the next.
*   **The final dish is the outcome of the Workflow**: This could be an API response, a completed data processing task, or any other desired result.

Workflows are typically initiated by [Triggers](./triggers.mdx), such as an incoming HTTP request, a scheduled event, or a message from a queue.

## Defining Workflows

Nanoservice-ts primarily uses JSON to define workflows. This declarative approach makes workflows easy to understand, visualize, and manage. A workflow definition typically includes:

*   **`name`**: A unique identifier for the workflow.
*   **`trigger`**: Configuration for the event that starts the workflow (e.g., HTTP method and path).
*   **`nodes`**: An array of Node instances that make up the workflow. Each node instance specifies:
    *   `id`: A unique identifier for this node instance within the workflow.
    *   `node`: The type or name of the Node to execute (e.g., `Http.Request`, `Utils.Logger`, or a custom node like `my-custom-node`).
    *   `input`: How data is mapped to the input schema of the Node. This can be static values, data from the trigger, or output from previous nodes.
    *   `next_node_id` (for sequential workflows): The `id` of the next node to execute upon successful completion.
    *   `on_error_node_id` (optional): The `id` of a node to execute if this node encounters an error.
    *   Other node-specific configuration parameters.

### Example: Simple HTTP Workflow (JSON Definition)

```json
{
  "name": "greetUser",
  "trigger": {
    "type": "Http",
    "config": {
      "path": "/greet",
      "method": "GET"
    }
  },
  "nodes": [
    {
      "id": "1",
      "node": "Utils.Logger",
      "input": {
        "message": "Greeting workflow started for path: {{trigger.path}}"
      },
      "next_node_id": "2"
    },
    {
      "id": "2",
      "node": "Http.SetResponse",
      "input": {
        "body": {
          "message": "Hello, Nanoservice User!"
        },
        "statusCode": 200
      }
    }
  ]
}
```

In this example:
1.  The workflow `greetUser` is triggered by a GET request to `/greet`.
2.  The first node (`id: "1"`) is a `Utils.Logger` that logs a message. It uses data from the trigger (`{{trigger.path}}`).
3.  Upon successful completion of node "1", node "2" (`Http.SetResponse`) is executed, which sends a JSON response back to the client.

While JSON is the primary method, Nanoservice-ts architecture also supports programmatic workflow definition in TypeScript for more dynamic or complex scenarios, though JSON is generally recommended for clarity and tooling support.

## Workflow Execution

When a trigger event occurs:

1.  The Nanoservice-ts runtime identifies the corresponding workflow.
2.  A new instance of the workflow is created.
3.  A [Context Object](./context.mdx) is initialized for this instance, containing trigger data and other relevant information.
4.  The runtime begins executing the nodes as defined in the workflow, passing data between them via the Context Object or direct input/output mapping.
5.  The workflow completes when it reaches a terminal node (a node with no `next_node_id`) or an explicit end state.

## Key Features of Workflows

*   **Declarative & Visualizable**: JSON definitions make it easier to understand the flow of logic.
*   **Reusable Nodes**: Build complex behaviors by composing simple, reusable Nodes.
*   **Data Flow Management**: Explicitly define how data is passed and transformed between Nodes.
*   **Error Handling**: Define specific paths for error conditions within the workflow.
*   **Conditional Logic & Branching**: More advanced workflows can include conditional execution paths (e.g., using a `Core.Condition` node or similar logic) to branch the flow based on data.
*   **Parallel Execution**: Some Nanoservice-ts runtimes or specific node types might support parallel execution of independent branches within a workflow for improved performance (consult specific runtime documentation).

## Creating Workflows

You can create workflow JSON files manually or use the `nanoctl` CLI:

```bash
nanoctl create workflow <workflow-name>
```

This command will typically generate a boilerplate workflow JSON file in your project's `workflows/` directory, which you can then customize.

Understanding workflows is crucial for effectively using Nanoservice-ts. They are the primary means by which you will build and structure your application logic.

Next, learn about the individual building blocks: [Nodes](./nodes.mdx).
