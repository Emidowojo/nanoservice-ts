---
title: CLI Node Management
---

# CLI: Node Management (`nanoctl create node`)

[Nodes](../introduction/nodes.mdx) are the core building blocks of your Nanoservice-ts applications, encapsulating specific pieces of logic. The `nanoctl` CLI provides commands to help you create and manage these Nodes efficiently, primarily through the `create node` command.

## `nanoctl create node <node-name>`

This command is used to scaffold a new Node within your Nanoservice-ts project.

**Purpose**: To generate the boilerplate files for a new Node, including its definition (`node.json`) and implementation file (e.g., `index.ts`), placing them in the appropriate directory within your project (usually `nodes/`).

**Usage**:

```bash
npx nanoctl@latest create node [node-name] [options]
# or if nanoctl is installed globally or as a project dependency
# nanoctl create node [node-name] [options]
```

*   **`[node-name]`** (required or prompted): The desired name for your Node. This name is often used to identify the Node type in workflow definitions. It should be descriptive and typically follow a convention like `Category.Action` (e.g., `Database.QueryUser`, `Utils.FormatString`). The CLI might enforce or suggest a naming convention.

**Interactive Prompts & Options**:

When you run `nanoctl create node`, you might be prompted for:

1.  **Node Name**: If not provided as an argument.
    ```
    ? What is the name of your new node? (e.g., MyCategory.MyActionNode) Stripe.CreatePayment
    ```

2.  **Node Description**: A brief description of what the Node does. This often populates the `description` field in `node.json`.
    ```
    ? Enter a short description for your node: Creates a new payment intent using Stripe.
    ```

3.  **(Potentially) Input/Output Schema Definition**: The CLI might offer a way to interactively define basic input and output properties for the Node, which would then be pre-filled in the `inputSchema` and `outputSchema` sections of `node.json`. This could be a simplified prompt or might direct you to edit the JSON file manually after creation.

4.  **(Potentially) Node Category/Path**: It might ask for a category to organize the node, which could influence the subdirectory where the node files are placed (e.g., `nodes/stripe/create-payment/`).

**What it Does**:

Upon completion, `nanoctl create node` will typically:

1.  Create a new directory for the Node, often within the `nodes/` directory of your project (e.g., `nodes/my-category/my-action-node/` or `nodes/MyCategory.MyActionNode/`).
2.  Generate a `node.json` file within this directory. This file will be pre-populated with the Node name, description, and boilerplate for `inputSchema` and `outputSchema`.
    ```json
    // Example generated node.json
    {
      "name": "Stripe.CreatePayment",
      "version": "1.0.0",
      "description": "Creates a new payment intent using Stripe.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "amount": { "type": "number", "description": "Payment amount" },
          "currency": { "type": "string", "description": "Currency code" }
        },
        "required": ["amount", "currency"]
      },
      "outputSchema": {
        "type": "object",
        "properties": {
          "paymentIntentId": { "type": "string" },
          "clientSecret": { "type": "string" }
        }
      }
    }
    ```
3.  Generate an implementation file, commonly `index.ts` (for TypeScript projects). This file will contain a template for the Node class or function, ready for you to fill in the execution logic.
    ```typescript
    // Example generated index.ts (conceptual)
    import { NanoserviceNode, NodeInput, NodeOutput, Context } from 'nanoservice-ts-sdk'; // SDK import

    // Define interfaces based on your node.json schema for better type safety
    interface StripeCreatePaymentInput {
      amount: number;
      currency: string;
    }

    interface StripeCreatePaymentOutput {
      paymentIntentId: string;
      clientSecret: string;
    }

    export class StripeCreatePaymentNode implements NanoserviceNode<StripeCreatePaymentInput, StripeCreatePaymentOutput> {
      async execute(input: NodeInput<StripeCreatePaymentInput>, context: Context): Promise<NodeOutput<StripeCreatePaymentOutput>> {
        const { amount, currency } = input.data;
        // const stripeApiKey = context.get('secrets.stripeApiKey'); // Example of accessing config

        // TODO: Implement Stripe API call logic here
        console.log(`Creating Stripe payment for ${amount} ${currency}`);

        // Placeholder response
        const paymentIntentId = 'pi_' + Math.random().toString(36).substr(2, 9);
        const clientSecret = 'cs_' + Math.random().toString(36).substr(2, 9);

        if (amount <= 0) {
          // Example of returning an error
          // return { error: { message: 'Amount must be positive', code: 'INVALID_INPUT' } };
          throw new Error('Amount must be positive'); // Or throw an error to be caught by the runtime
        }

        return {
          data: {
            paymentIntentId,
            clientSecret
          }
        };
      }
    }
    ```

**Example Invocation**:

To create a new Node named `User.GetProfile`:

```bash
npx nanoctl@latest create node User.GetProfile
```

The CLI will then likely prompt for a description and generate the files in `nodes/user/get-profile/` or a similar path.

## Best Practices for Node Naming and Structure

*   **Clear Naming**: Use a consistent naming convention that clearly indicates the Node's purpose and category (e.g., `Service.VerbNoun` like `Stripe.CreatePaymentIntent`, `AwsS3.UploadFile`).
*   **Single Responsibility**: Ensure each Node adheres to the Single Responsibility Principle.
*   **Well-Defined Schemas**: Spend time defining clear and accurate `inputSchema` and `outputSchema` in your `node.json`. This serves as the contract for your Node and enables validation.

The `create node` command significantly speeds up the initial setup for new Nodes, allowing you to focus more on implementing the core logic.

Next, learn about managing [Workflows with the CLI](./workflows.mdx).
