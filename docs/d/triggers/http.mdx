---
title: HTTP
---

## Concept

HTTP (Hypertext Transfer Protocol) is the foundation of data communication for the World Wide Web and is a primary mechanism for building APIs and web services. Nanoservice-TS provides robust support for creating HTTP-triggered workflows and using Nodes that interact via HTTP.

This page covers how Nanoservice-TS handles HTTP communication, focusing on HTTP triggers and common HTTP-related Nodes.

## HTTP Triggers

An HTTP Trigger allows a Nanoservice-TS [Workflow](../introduction/workflows.mdx) to be initiated by an incoming HTTP request. This is essential for building RESTful APIs, webhooks, or any service that needs to respond to web requests.

### Configuration

As shown in the [Triggers](../introduction/triggers.mdx) section, an HTTP trigger is configured within a workflow definition (typically JSON) and specifies:

*   **`type: "Http"`**: Identifies the trigger as HTTP-based.
*   **`config`**: An object containing specific settings for the HTTP trigger:
    *   **`path`** (string, required): The URL path that will activate this workflow (e.g., `/users`, `/products/{productId}`). Path parameters (like `{productId}`) are supported and become available in the workflow's [Context Object](../introduction/context.mdx).
    *   **`method`** (string, required): The HTTP method the trigger listens for (e.g., `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`).
    *   **(Optional) Other configurations**: Depending on the Nanoservice-TS runtime, there might be options for CORS, authentication middleware, request size limits, etc.

### Example: HTTP Trigger for a POST Request

```json
// In workflow.json
{
  "name": "createUserWorkflow",
  "trigger": {
    "type": "Http",
    "config": {
      "path": "/users",
      "method": "POST"
    }
  },
  "nodes": [
    // ... nodes to handle user creation ...
  ]
}
```
This workflow starts when a `POST` request is made to the `/users` endpoint.

### Request Data in Context

When an HTTP trigger fires, information from the incoming HTTP request is populated into the workflow's Context Object. This typically includes:

*   **`context.trigger.method`**: The HTTP method (e.g., "GET").
*   **`context.trigger.path`**: The request path.
*   **`context.trigger.headers`**: An object containing request headers (e.g., `context.trigger.headers['content-type']`).
*   **`context.trigger.query`**: An object containing URL query parameters (e.g., for `/search?term=nanoservice`, `context.trigger.query.term` would be "nanoservice").
*   **`context.trigger.params`**: An object containing values from named path parameters (e.g., for path `/users/{id}` and request `/users/123`, `context.trigger.params.id` would be "123").
*   **`context.trigger.body`**: The request body. If the `Content-Type` is `application/json`, the body is usually pre-parsed into a JavaScript object. For other types like `text/plain` or `application/x-www-form-urlencoded`, it might be a string or an object accordingly.

## Common HTTP-Related Nodes

Nanoservice-TS workflows often involve Nodes that either make HTTP requests to external services or control the HTTP response sent back to the client that triggered the workflow.

### 1. `Http.Request` Node (or similar)

This type of Node is used to make outbound HTTP requests from within a workflow to other APIs or services.

*   **Purpose**: To fetch data from, or send data to, external HTTP endpoints.
*   **Key Inputs (Conceptual)**:
    *   `url`: The target URL.
    *   `method`: HTTP method (GET, POST, PUT, DELETE, etc.).
    *   `headers`: Request headers.
    *   `body`: Request payload (for POST, PUT, etc.).
    *   `queryParams`: URL query parameters.
    *   `timeout`: Request timeout in milliseconds.
*   **Key Outputs (Conceptual)**:
    *   `statusCode`: The HTTP status code of the response (e.g., 200, 404, 500).
    *   `headers`: Response headers from the external service.
    *   `body`: The response body (often automatically parsed if JSON).

**Example Usage in a Workflow:**
```json
{
  "id": "fetch_external_data",
  "node": "Http.Request",
  "input": {
    "url": "https://api.example.com/data/{{trigger.params.itemId}}",
    "method": "GET",
    "headers": {
      "Authorization": "Bearer {{context.secrets.apiToken}}"
    }
  },
  "next_node_id": "process_data"
}
```

### 2. `Http.SetResponse` Node (or similar)

This Node is used in HTTP-triggered workflows to construct and send the HTTP response back to the original caller.

*   **Purpose**: To define the status code, headers, and body of the HTTP response.
*   **Key Inputs (Conceptual)**:
    *   `statusCode` (number): The HTTP status code to return (e.g., 200, 201, 400, 404, 500).
    *   `body` (any): The response body. If an object or array, it's typically serialized as JSON with `Content-Type: application/json` unless overridden.
    *   `headers` (object): Custom HTTP headers to include in the response (e.g., `{"Content-Type": "text/plain"}`, `{"Cache-Control": "no-cache"}`).
    *   `redirectUrl` (string, optional): If provided, the node might issue an HTTP redirect (e.g., with a 301 or 302 status code).

**Example Usage in a Workflow:**
```json
{
  "id": "send_success_response",
  "node": "Http.SetResponse",
  "input": {
    "statusCode": 200,
    "body": {
      "message": "Operation successful",
      "data": "{{nodes.process_item.output.result}}"
    }
  }
}
// No next_node_id typically, as this often terminates the workflow path for a successful response.
```

### 3. `UI.RenderHtml` Node (or similar)

As seen in the [Single Page UI Example](../examples/single-page-ui.mdx), some Nodes might specialize in returning specific content types, like HTML.

*   **Purpose**: To easily send HTML content with the correct `Content-Type` header.
*   **Key Inputs (Conceptual)**:
    *   `htmlContent` (string): The HTML string.
    *   `statusCode` (number, default: 200).
    *   `headers` (object, often defaults `Content-Type` to `text/html`).

## Best Practices for HTTP in Nanoservice-TS

*   **Statelessness**: Aim for stateless HTTP-triggered workflows where possible. Each request should contain all necessary information, or rely on data fetched by Nodes within that workflow instance.
*   **Idempotency**: For `PUT` or `DELETE` operations, or any operation that might be retried, strive for idempotency where appropriate.
*   **Error Handling**: Use workflow logic to catch errors from `Http.Request` Nodes (e.g., network issues, 4xx/5xx responses from external services) and use `Http.SetResponse` to return meaningful error responses to the client.
*   **Input Validation**: Validate incoming request data (body, query, params) early in your workflow, often using a dedicated validation Node or the `inputSchema` of your first processing Node.
*   **Security**: Be mindful of security best practices:
    *   Validate and sanitize all inputs.
    *   Implement authentication and authorization (this might be handled by a gateway in front of Nanoservice-TS or by dedicated Nodes/middleware within the workflow).
    *   Be careful with what data is logged from requests and responses.
    *   Use HTTPS.

HTTP communication is a cornerstone of modern web applications, and Nanoservice-TS provides the necessary tools through triggers and specialized Nodes to build powerful and flexible HTTP-based services.
