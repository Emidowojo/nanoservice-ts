---
title: External API Integration
---

Nanoservice-ts Nodes frequently need to communicate with external APIs, whether they are third-party services (like payment gateways, social media APIs, weather services) or other microservices within your own infrastructure. Effectively integrating with these APIs is a common requirement for building feature-rich applications.

This guide outlines best practices and patterns for calling external RESTful or GraphQL APIs from within your Nanoservice-ts Nodes.

## Choosing an HTTP Client

To make HTTP requests from your Node.js-based Nanoservice Nodes, you'll need an HTTP client library. Popular choices include:

-   **Axios:** A widely-used, promise-based HTTP client for the browser and Node.js. It offers a simple API, automatic JSON data transformation, and error handling features.
-   **node-fetch:** A lightweight module that brings the `fetch` API (standard in modern browsers) to Node.js. It's also promise-based and well-suited for simple requests.
-   **Got:** A powerful and modern HTTP request library for Node.js, known for its extensive features and performance.

For most use cases, Axios is a solid and developer-friendly choice. The examples below will primarily use Axios.

```bash
# Install Axios in your project (if not already a dependency of a node)
npm install axios
# or, if managing dependencies per-node, add to the node's package.json and install
```

## Calling RESTful APIs

### Basic GET Request

```typescript
// src/nodes/my-api-caller-node/index.ts
import { type INanoServiceResponse, NanoService, NanoServiceResponse } from "@nanoservice-ts/runner";
import { type Context, GlobalError } from "@nanoservice-ts/shared";
import axios, { AxiosError } from 'axios';

type InputType = { queryParams?: Record<string, any> };
type OutputType = { apiResponse: any };

export default class MyApiCallerNode extends NanoService<InputType> {
  constructor() {
    super();
    // Define input/output schemas
    this.inputSchema = {
      type: "object",
      properties: {
        queryParams: { type: "object" }
      }
    };
    // Output schema should reflect the expected API response structure
  }

  async handle(ctx: Context, inputs: InputType): Promise<INanoServiceResponse> {
    const response: NanoServiceResponse = new NanoServiceResponse();
    const baseUrl = process.env.EXTERNAL_API_BASE_URL || "https://api.thirdparty.com/v1";
    const apiKey = process.env.EXTERNAL_API_KEY;

    if (!apiKey) {
      response.setError(new GlobalError("API key is not configured.", 500));
      return response;
    }

    try {
      ctx.logger.info("Calling external API", { baseUrl, params: inputs.queryParams });
      const apiResponse = await axios.get(`${baseUrl}/data`, {
        params: inputs.queryParams, // e.g., { search: 'nanoservice', limit: 10 }
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "X-Custom-Header": "NanoserviceTS-Client"
        },
        timeout: 5000 // 5 seconds timeout
      });

      response.setSuccess({ apiResponse: apiResponse.data });
      ctx.logger.debug("External API call successful", { statusCode: apiResponse.status });

    } catch (error: unknown) {
      const err = error as AxiosError;
      ctx.logger.error("Error calling external API", { 
        message: err.message,
        code: err.code,
        status: err.response?.status,
        responseData: err.response?.data
      });
      const errorMessage = (err.response?.data as any)?.message || err.message || "Failed to call external API.";
      response.setError(new GlobalError(errorMessage, err.response?.status || 500));
    }
    return response;
  }
}
```

### POST Request with JSON Body

```typescript
// ... (inside handle method of a similar node)
    try {
      const postData = {
        name: "New Item",
        value: 123,
        tags: ["example", "nanoservice"]
      };
      // Ensure postData matches the InputType or is derived from inputs

      ctx.logger.info("Posting data to external API", { baseUrl, data: postData });
      const apiResponse = await axios.post(`${baseUrl}/items`, postData, {
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        },
        timeout: 10000 // 10 seconds timeout for POST
      });

      response.setSuccess({ createdItem: apiResponse.data });
      ctx.logger.debug("External API POST successful", { statusCode: apiResponse.status });

    } catch (error: unknown) {
      // ... (similar error handling as GET request) ...
    }
// ...
```

## Calling GraphQL APIs

To call GraphQL APIs, you typically send a POST request with the GraphQL query (and variables, if any) in the request body.

```typescript
// ... (inside handle method)
    const graphqlEndpoint = process.env.GRAPHQL_API_ENDPOINT || "https://api.thirdparty.com/graphql";
    const query = `
      query GetUserDetails($userId: ID!) {
        user(id: $userId) {
          id
          name
          email
          posts {
            title
          }
        }
      }
    `;
    const variables = { userId: inputs.userId }; // Assuming userId is in inputs

    try {
      ctx.logger.info("Calling GraphQL API", { graphqlEndpoint, query, variables });
      const apiResponse = await axios.post(graphqlEndpoint, 
        {
          query: query,
          variables: variables
        },
        {
          headers: {
            "Authorization": `Bearer ${apiKey}`,
            "Content-Type": "application/json"
          },
          timeout: 7000
        }
      );

      if (apiResponse.data.errors) {
        ctx.logger.error("GraphQL API returned errors", { errors: apiResponse.data.errors });
        // Handle GraphQL-specific errors (which might still be a 200 OK HTTP response)
        response.setError(new GlobalError(apiResponse.data.errors[0].message, 400)); 
      } else {
        response.setSuccess({ graphqlData: apiResponse.data.data });
        ctx.logger.debug("GraphQL API call successful");
      }

    } catch (error: unknown) {
      // ... (similar HTTP error handling, but also consider GraphQL errors above) ...
    }
// ...
```

## Best Practices for API Integration in Nodes

1.  **Configuration for API Endpoints and Keys:**
    -   Store base URLs, API keys, and other sensitive credentials in environment variables (see [Configuration](./../fundamentals/configuration.mdx)).
    -   Pass these to your Node via workflow inputs using `{{env.VAR_NAME}}` or access them directly using `process.env` within the Node.

2.  **Error Handling:**
    -   Always wrap API calls in `try...catch` blocks.
    -   Inspect the error object (e.g., `AxiosError`) to get specific details like HTTP status codes and response bodies from the failed API call.
    -   For GraphQL, check for an `errors` array in the response data even if the HTTP status is 200.
    -   Return meaningful errors from your Node using `response.setError()`.

3.  **Timeouts:**
    -   Configure appropriate timeouts for your HTTP requests to prevent your Node from hanging indefinitely if an external API is slow or unresponsive.

4.  **Retries:**
    -   For transient errors (e.g., network issues, temporary server errors like 502, 503, 504), consider implementing a retry mechanism with exponential backoff. Libraries like `axios-retry` or `async-retry` can simplify this.
    -   Be cautious with retrying non-idempotent operations (like POST requests that create resources) unless the API supports idempotency keys.

5.  **Data Validation and Transformation:**
    -   Validate the data received from external APIs against an expected schema before processing it further or returning it from your Node. This helps catch unexpected API changes.
    -   Transform API responses into a consistent format that your workflow or subsequent Nodes expect.

6.  **Logging:**
    -   Use `ctx.logger` to log important information about API calls, such as the request being made (without sensitive data in production logs), the response status, and any errors.

7.  **Idempotency (for write operations):**
    -   If you are making calls that modify data (POST, PUT, DELETE), understand the idempotency characteristics of the external API. If the API supports idempotency keys, use them to prevent accidental duplicate operations in case of retries.

8.  **Keep Nodes Focused:**
    -   If a Node needs to interact with multiple complex APIs or perform extensive data manipulation related to API responses, consider breaking it down into smaller, more focused Nodes orchestrated by a workflow.

9.  **API Documentation:**
    -   Thoroughly read the documentation of the external API you are integrating with to understand its authentication methods, rate limits, error codes, and data formats.

By following these practices, you can build reliable and robust Nanoservice-ts Nodes that effectively integrate with a wide range of external APIs.
