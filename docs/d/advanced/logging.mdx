---
title: Logging Best Practices
---

Effective logging is crucial for debugging, monitoring, and understanding the behavior of your Nanoservice-ts applications. A well-thought-out logging strategy can significantly reduce the time it takes to identify and resolve issues in both development and production environments.

Nanoservice-ts provides a context logger (`ctx.logger`) within Nodes, which should be your primary interface for logging.

## Using `ctx.logger`

The context object (`ctx`) passed to every Node's `handle` method includes a `logger` instance. This logger is typically pre-configured by the Nanoservice-ts runtime.

```typescript
// Inside a Node's handle method
async handle(ctx: Context, inputs: InputType): Promise<INanoServiceResponse> {
  const response = new NanoServiceResponse();
  try {
    ctx.logger.debug("Node execution started", { nodeId: this.constructor.name, inputs });

    // ... your Node's logic ...
    const result = "some data";
    ctx.logger.info("Successfully processed data", { resultLength: result.length });

    if (inputs.someFlag === true) {
      ctx.logger.warn("A specific condition was met that might need attention.", { flagValue: inputs.someFlag });
    }

    response.setSuccess({ data: result });

  } catch (error: unknown) {
    const err = error as Error;
    // Log the error with stack trace and relevant context
    ctx.logger.error(`Error in ${this.constructor.name}: ${err.message}`, {
      errorName: err.name,
      errorMessage: err.message,
      stack: err.stack,
      nodeInputs: inputs
    });
    response.setError(new GlobalError(err.message, 500));
  }
  return response;
}
```

### Logger Methods / Log Levels

The `ctx.logger` typically supports standard log levels:

-   **`ctx.logger.debug(...)`**: Detailed information useful for debugging. These logs are often disabled in production to reduce noise but are invaluable during development.
-   **`ctx.logger.info(...)`**: General information about the application's operation (e.g., Node started, task completed, significant events).
-   **`ctx.logger.warn(...)`**: Indicates a potential issue or an unexpected situation that doesn't necessarily prevent the current operation from completing but might lead to problems later.
-   **`ctx.logger.error(...)`**: Signals an error that prevented an operation from completing successfully. Always include as much context as possible, especially the error object and stack trace.
-   **`ctx.logger.fatal(...)` (or similar for critical errors):** For severe errors that might require the application to terminate or indicate a critical system failure. (Availability might depend on the underlying logger implementation used by Nanoservice-ts).

## What to Log

Effective logging involves recording the right information at the right time.

-   **Node Entry and Exit:** Log when a Node's `handle` method is invoked and when it completes (both success and failure). Include input parameters (be mindful of sensitive data).
-   **Key Decisions and Branching:** If your Node has significant conditional logic, log which path was taken and why.
-   **External Interactions:** Log requests made to external APIs or databases (URL, method, parameters - again, sanitize sensitive data) and the responses received (status code, key identifiers from the response).
-   **Errors:** Always log errors with stack traces and relevant contextual information (inputs, state variables).
-   **Significant State Changes:** If a Node modifies important data or state, log the change.
-   **Performance Metrics (Optional):** You might log the duration of critical operations within a Node.
-   **Configuration Values:** At startup, or when relevant, log important configuration values being used (excluding secrets).

## Structured Logging

**This is highly recommended.** Instead of logging plain text strings, log messages as JSON objects or another structured format.

**Why Structured Logging?**

-   **Machine-Readable:** Makes logs easy to parse, query, and analyze by log management systems (e.g., Elasticsearch/Kibana (ELK), Splunk, Datadog, Grafana Loki).
-   **Rich Context:** Allows you to include multiple key-value pairs of contextual information with each log message.
-   **Filtering and Searching:** Enables powerful filtering and searching based on specific fields (e.g., `userId`, `orderId`, `nodeName`, `errorCode`).

**Example of Structured Logging with `ctx.logger`:**

The `ctx.logger` in Nanoservice-ts often supports passing an object as the second argument, which gets incorporated into the structured log output.

```typescript
ctx.logger.info("User login successful", {
  userId: inputs.userId,
  ipAddress: ctx.trigger?.ip, // Assuming IP is available in context from trigger
  node: this.constructor.name
});

ctx.logger.error("Failed to connect to database", {
  dbHost: process.env.DB_HOST,
  errorCode: dbError.code,
  errorMessage: dbError.message,
  node: this.constructor.name
});
```

If Nanoservice-ts uses a logger like Pino or Winston under the hood, this structured logging capability is usually built-in.

## Log Levels Configuration

Log verbosity should be configurable per environment:

-   **Development:** Set to `DEBUG` to get detailed information for troubleshooting.
-   **Staging/Testing:** Might also be `DEBUG` or `INFO`.
-   **Production:** Typically set to `INFO` or `WARN` to reduce log volume and performance overhead. `DEBUG` logs are usually too verbose for production unless temporarily enabled to diagnose a specific issue.

This configuration is often managed via an environment variable (e.g., `LOG_LEVEL`). The Nanoservice-ts runtime or the underlying logger library would read this variable.

## Sensitive Data

**Never log sensitive information in plain text.** This includes:

-   Passwords
-   API keys, tokens, secrets
-   Credit card numbers or other financial details
-   Personally Identifiable Information (PII) unless absolutely necessary and properly secured/anonymized/masked.

**Strategies for Handling Sensitive Data:**

-   **Omission:** Simply don't log it.
-   **Masking:** Replace parts of the sensitive data with placeholders (e.g., `"password": "********"`).
-   **Hashing/Encryption (Rarely for logs):** While possible, it's often overly complex for general logging and better suited for data at rest.
-   **Tokenization:** Replace sensitive data with non-sensitive tokens.

Ensure your logging library or custom logging formatters can help with automatic masking of predefined sensitive fields.

## Correlation IDs (Trace IDs)

For tracking a single request or transaction as it flows through multiple Nodes or even multiple services (if your Nanoservice-ts app interacts with other microservices), use a **Correlation ID** (also known as a Trace ID or Request ID).

-   Generate a unique ID when a request first enters your system (e.g., at the HTTP trigger).
-   Pass this ID through the `ctx` object or as part of the data flowing between Nodes.
-   Include this Correlation ID in every log message related to that request/transaction.

This allows you to easily filter and view all logs associated with a specific operation, which is invaluable for debugging complex or distributed workflows.

```typescript
// At the trigger or an initial workflow step (conceptual)
// const correlationId = uuidv4(); 
// ctx.correlationId = correlationId; // If context is mutable or passed along

// In a Node
ctx.logger.info("Processing payment", {
  correlationId: ctx.correlationId, // Assuming it's available
  orderId: inputs.orderId,
  amount: inputs.amount
});
```

## Log Management and Analysis

In production, logs should be shipped to a centralized log management system. These systems provide:

-   Storage and retention
-   Powerful search and filtering capabilities
-   Visualization and dashboards
-   Alerting based on log patterns or error rates

Popular choices include ELK Stack (Elasticsearch, Logstash, Kibana), Splunk, Datadog, Grafana Loki, AWS CloudWatch Logs, Google Cloud Logging.

## Best Practices Summary

1.  **Use `ctx.logger`:** Leverage the provided contextual logger.
2.  **Embrace Structured Logging:** Log JSON objects for better analysis.
3.  **Use Appropriate Log Levels:** Configure verbosity per environment.
4.  **Log Key Events:** Record Node entry/exit, decisions, external calls, and errors.
5.  **Protect Sensitive Data:** Never log secrets; mask or omit PII.
6.  **Implement Correlation IDs:** Trace requests across Nodes/services.
7.  **Be Concise but Informative:** Logs should provide enough detail without being excessively verbose.
8.  **Centralize Logs in Production:** Use a log management system.
9.  **Regularly Review Logs:** Especially in production, to proactively identify issues or trends.

By following these logging best practices, you can significantly improve the observability, debuggability, and reliability of your Nanoservice-ts applications.
