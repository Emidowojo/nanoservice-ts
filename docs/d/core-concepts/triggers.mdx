---
title: Triggers
---

# Triggers: Initiating Workflows

In Nanoservice-ts, **Triggers** are the mechanisms that initiate the execution of a Workflow. They act as the entry point, listening for specific events or conditions and then starting the corresponding Workflow, often passing initial data to it.

Think of a trigger as the starting gun for a race, the doorbell ringing, or a scheduled alarm – it’s the event that sets a process in motion.

## Concept and Role

The primary role of a Trigger is to decouple the Workflow execution from the event source. This means a single Workflow can potentially be initiated by various means (e.g., an HTTP request, a scheduled task, or a message from a queue) without changing the Workflow's core logic.

When a Trigger fires, it typically provides initial data (e.g., HTTP request body, query parameters, or event payload) that can be accessed within the Workflow using the `{{trigger...}}` templating syntax.

## Common Trigger Types

Nanoservice-ts supports several types of triggers, which are defined within the `trigger` object in your Workflow JSON definition.

### 1. HTTP Triggers

HTTP Triggers are the most common way to expose your Workflows as web APIs. They listen for incoming HTTP requests and execute the Workflow.

**Configuration in Workflow JSON:**

```json
{
  "name": "my-api-workflow",
  "trigger": {
    "http": {
      "method": "POST",               // HTTP method: GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD, or *
      "path": "/users/:userId/orders", // URL path. Supports path parameters like :userId
      "accept": "application/json",    // Optional: Expected request Content-Type
      "responseType": "application/json" // Optional: Content-Type for the response
    }
  },
  "steps": [
    // ... your workflow steps
  ]
}
```

-   **`method`**: Specifies the HTTP method the trigger should respond to. Common values include `GET`, `POST`, `PUT`, `DELETE`, `PATCH`. Use `*` to match any method.
-   **`path`**: Defines the URL path for the endpoint. You can include path parameters using the colon prefix (e.g., `/:id`, `/:category/:productId`). These parameters become available in the workflow via `{{trigger.params.id}}`.
-   **`accept`**: (Optional) Specifies the `Content-Type` header the trigger expects for incoming requests (e.g., `application/json`, `text/plain`).
-   **`responseType`**: (Optional) Specifies the `Content-Type` for the response sent back by the workflow. Defaults to `application/json` if not specified.

**Accessing HTTP Trigger Data in Workflow:**

-   `{{trigger.body}}`: The parsed request body (e.g., for POST, PUT requests).
-   `{{trigger.query}}`: An object containing the URL query parameters (e.g., `/search?term=nanoservice` -> `{{trigger.query.term}}`).
-   `{{trigger.params}}`: An object containing the path parameters (e.g., `/users/:id` with request `/users/123` -> `{{trigger.params.id}}` is `123`).
-   `{{trigger.headers}}`: An object containing the request headers (e.g., `{{trigger.headers.authorization}}`).
-   `{{trigger.ip}}`: The IP address of the client making the request.
-   `{{trigger.method}}`: The HTTP method of the request.
-   `{{trigger.path}}`: The path of the request.

### 2. Schedule Triggers

Schedule Triggers allow you to run Workflows at predefined times or intervals, similar to cron jobs.

**Configuration in Workflow JSON:**

```json
{
  "name": "daily-report-workflow",
  "trigger": {
    "schedule": {
      "cron": "0 9 * * MON-FRI", // Cron expression (e.g., every weekday at 9 AM)
      "timezone": "America/New_York" // Optional: Specify timezone
    }
  },
  "steps": [
    // ... steps to generate and send a daily report
  ]
}
```

-   **`cron`**: A cron-style expression defining the schedule. The format is `(Minute) (Hour) (DayofMonth) (Month) (DayofWeek)`.
    -   Example: `0 0 * * *` (every day at midnight)
    -   Example: `*/15 * * * *` (every 15 minutes)
-   **`timezone`**: (Optional) Specifies the timezone for the cron expression (e.g., `UTC`, `Europe/London`). If not provided, it typically defaults to the server's timezone.

When a Schedule Trigger fires, `{{trigger.timestamp}}` (ISO 8601 string) and `{{trigger.date}}` (Date object) might be available, representing the time the trigger fired.

### 3. Event Triggers (Conceptual)

While Nanoservice-ts core might provide a generic way to integrate with event-driven systems, specific Event Triggers (like for Kafka, RabbitMQ, AWS SQS, or third-party webhooks) might be implemented as specialized nodes or require custom integration patterns.

The general idea is that the Workflow would be triggered by an incoming message or event from an external system.

**Example (Conceptual for a Message Queue):**

```json
// This is a conceptual example, actual implementation may vary
{
  "name": "process-new-order-event",
  "trigger": {
    "messageQueue": {
      "queueName": "new-orders",
      "brokerUrl": "{{env.MESSAGE_BROKER_URL}}"
    }
  },
  "steps": [
    // ... steps to process the order data from {{trigger.payload}}
  ]
}
```

In such cases, `{{trigger.payload}}` or similar would likely contain the data from the event.

## Custom Triggers

The Nanoservice-ts framework is designed to be extensible. While HTTP and Schedule triggers are common built-in types, it's often possible to develop custom trigger mechanisms if your application has unique requirements for initiating workflows. This might involve creating a custom listener that programmatically invokes workflows via the Nanoservice-ts runtime.

## Choosing the Right Trigger

-   Use **HTTP Triggers** when you need to expose functionality over the web, build RESTful APIs, or respond to direct user actions.
-   Use **Schedule Triggers** for recurring tasks, batch jobs, maintenance routines, or anything that needs to run automatically at specific times.
-   Consider **Event Triggers** or custom solutions when integrating with message queues, event streams, or other asynchronous systems.

By understanding and correctly configuring triggers, you can effectively control how and when your Nanoservice-ts workflows are executed, forming a critical part of your application's architecture.
