---
title: Workflows (Orchestration)
---

# Fundamentals: Workflows (Orchestration)

While Nodes in Nanoservice-ts encapsulate individual pieces of logic, **Workflows** are responsible for orchestrating these Nodes to perform more complex, multi-step processes. A Workflow defines the sequence of Node executions, how data flows between them, and how decisions are made along the way.

Think of a Workflow as the conductor of an orchestra, guiding each musician (Node) to play their part at the right time to create a harmonious symphony (the desired outcome).

## Core Concepts of a Workflow

### 1. Declarative Definition (JSON)

Workflows in Nanoservice-ts are primarily defined declaratively using a JSON structure. This JSON file specifies:

-   **`name`**: A unique identifier for the workflow.
-   **`version`**: Version of the workflow.
-   **`description`**: A brief explanation of what the workflow does.
-   **`trigger`**: How the workflow is initiated (e.g., HTTP request, schedule). See [Triggers](./triggers.mdx).
-   **`steps`**: An ordered array defining the sequence of Node executions.
-   **`nodes`**: Configuration for each Node instance used in the `steps`, including their inputs.
-   **`output`**: (Optional) Defines how the final output of the workflow is constructed.

**Example Workflow JSON (`workflows/json/my-user-processing-workflow.json`):**

```json
{
  "name": "user-processing-workflow",
  "version": "1.0.0",
  "description": "Fetches user details, processes them, and sends a notification.",
  "trigger": {
    "http": {
      "method": "POST",
      "path": "/users/process"
    }
  },
  "steps": [
    {
      "name": "get-user-data-step",
      "node": "fetch-user-node", // Name of the registered Node
      "type": "module" // Indicates a Nanoservice-ts Node
    },
    {
      "name": "transform-user-data-step",
      "node": "transform-data-node",
      "type": "module",
      "condition": "{{get-user-data-step.output.isActive}}" // Conditional execution
    },
    {
      "name": "send-notification-step",
      "node": "send-email-node",
      "type": "module"
    }
  ],
  "nodes": {
    "get-user-data-step": {
      "inputs": {
        "userId": "{{trigger.body.userId}}" // Data from HTTP trigger body
      }
    },
    "transform-user-data-step": {
      "inputs": {
        "rawData": "{{get-user-data-step.output}}", // Output from previous step
        "format": "summary"
      }
    },
    "send-notification-step": {
      "inputs": {
        "to": "{{get-user-data-step.output.email}}",
        "subject": "Your data has been processed",
        "body": "Hello {{get-user-data-step.output.name}}, your information was updated: {{transform-user-data-step.output.summaryDetails}}"
      }
    }
  },
  "output": {
    "success": {
      "statusCode": 200,
      "body": {
        "message": "User processed successfully.",
        "userId": "{{trigger.body.userId}}",
        "notificationSentTo": "{{get-user-data-step.output.email}}"
      }
    },
    "error": {
      "statusCode": 500,
      "body": {
        "message": "Failed to process user: {{error.message}}"
      }
    }
  }
}
```

### 2. Steps

The `steps` array defines the sequence of operations. Each object in the `steps` array represents an execution of a Node.

-   **`name`**: A unique name for this step within the workflow. This name is used to reference the step elsewhere (e.g., for accessing its output or in conditions).
-   **`node`**: The registered name of the Nanoservice Node to execute (e.g., `"fetch-user-node"` which corresponds to a key in `src/Nodes.ts`).
-   **`type`**: Typically `"module"` for standard Nanoservice-ts Nodes.
-   **`condition` (Optional)**: A string expression that, if it evaluates to a truthy value, allows the step to execute. If falsy, the step is skipped. Uses the same templating syntax (e.g., `"{{previous-step.output.someFlag}}"`).
-   **`onError` (Optional)**: Defines behavior if this step errors (e.g., `"continue"` to proceed to the next step, or `"failWorkflow"` which is default).

### 3. Node Configuration (`nodes` object)

The `nodes` object provides the specific configuration for each named step defined in the `steps` array.

-   The key in the `nodes` object matches the `name` of a step (e.g., `"get-user-data-step"`).
-   **`inputs`**: An object defining the data to be passed to the Node for this specific execution. Values can be:
    -   Static values (strings, numbers, booleans).
    -   Templated expressions using `{{...}}` to access:
        -   Trigger data: `{{trigger.body.field}}`, `{{trigger.query.param}}`, `{{trigger.params.id}}`.
        -   Output from previous steps: `{{step-name.output.field}}`.
        -   Environment variables: `{{env.API_KEY}}`.
        -   Workflow context (if manipulated): `{{context.someValue}}`.
        -   Error information from a previous step (if `onError: "continue"` was used): `{{step-name.error.message}}`.

### 4. Data Flow (Templating)

Data flows between Nodes and from the trigger using a simple templating system (often based on Handlebars or a similar syntax like `{{expression}}`).

-   `{{trigger.body.someField}}`: Accesses `someField` from the trigger object (e.g., HTTP request body).
-   `{{previousStepName.output.someProperty}}`: Accesses `someProperty` from the output of a previously executed step named `previousStepName`.
-   `{{env.MY_VARIABLE}}`: Accesses the environment variable `MY_VARIABLE`.

This allows you to dynamically wire the output of one Node to the input of another.

### 5. Conditional Logic (`condition`)

Steps can be executed conditionally based on the output of previous steps or other data available in the workflow context. The `condition` property on a step uses the same templating syntax. If the expression in `condition` evaluates to a truthy value (e.g., `true`, a non-empty string, a non-zero number), the step runs. Otherwise, it is skipped.

### 6. Error Handling

-   If a Node in a step returns an error (via `response.setError()`), the workflow by default will stop execution and can return an error response (defined in the `output.error` section of the workflow).
-   The `onError` property in a step definition can modify this behavior (e.g., `"continue"` allows the workflow to proceed to the next step, making the error information from the failed step available via `{{failed-step-name.error}}`).
-   Nanoservice-ts also supports more advanced error handling patterns like try/catch blocks within workflows, often implemented using special control flow nodes or workflow structures.

### 7. Workflow Output (`output` object)

The optional `output` object in the workflow JSON defines how the final response of the workflow is constructed, typically for HTTP triggers.

-   **`output.success`**: Defines the response when the workflow completes successfully.
-   **`output.error`**: Defines the response when the workflow encounters an unhandled error.

Both can specify `statusCode` and a `body`, which can also use the templating syntax to include data from trigger, steps, or environment variables.

## Generating Workflows with `nanoctl`

The Nanoservice-ts CLI (`nanoctl`) helps you create new workflow files:

```bash
# Navigate to your project root
cd my-nanoservice-project

# Run the workflow creation command
npx nanoctl@latest create workflow
```

The CLI will prompt for:

-   Workflow name (e.g., `customer-onboarding`)
-   Description
-   Trigger type (e.g., HTTP, Schedule)
-   Specific trigger configurations (e.g., HTTP path and method)

This will generate a basic workflow JSON file in the `workflows/json/` directory, which you can then customize.

## Programmatic Workflows (TypeScript - Advanced)

While JSON is the primary way to define workflows, Nanoservice-ts may also support or allow for programmatic workflow definition using TypeScript for more dynamic or complex scenarios. This typically involves using helper functions or classes provided by the framework to construct the workflow structure in code.

## Best Practices for Workflow Design

-   **Clarity and Readability:** Keep workflow definitions as clear and easy to understand as possible. Use meaningful names for steps.
-   **Modularity:** Break down complex processes into smaller, manageable workflows if necessary. One workflow could potentially trigger another.
-   **Reuse Nodes:** Leverage the reusability of your Nodes across different workflows.
-   **Data Transformation:** Use dedicated transformation Nodes if data needs significant reshaping between steps, rather than putting complex transformation logic directly in the templating.
-   **Error Handling Strategy:** Define a clear error handling strategy for your workflows. Decide when a step failure should halt the entire workflow versus when it should be caught and handled.
-   **Idempotency:** For workflows that modify data, consider how to make them idempotent (i.e., running them multiple times with the same input produces the same result without unintended side effects), especially if triggers might fire multiple times (e.g., due to retries).
-   **Testing:** Test your workflows thoroughly, including different paths based on conditional logic and various error scenarios.

Workflows are the orchestrators that bring your Nanoservice Nodes together to deliver business value. By mastering their declarative structure and capabilities, you can build sophisticated and robust backend applications with Nanoservice-ts.
