---
title: Nodes (Custom Logic)
---

# Fundamentals: Nodes (Custom Logic)

At the heart of Nanoservice-ts are **Nodes**. Nodes are reusable, single-purpose TypeScript classes that encapsulate a specific piece of business logic or a technical capability. They are the fundamental building blocks that you combine within Workflows to create complex backend processes and APIs.

Think of a Node as a specialized worker on an assembly line. Each worker (Node) performs a distinct task, and by arranging them in a specific order (Workflow), you can produce a complete product.

## Core Concepts of a Node

### 1. Single Responsibility

Each Node should ideally adhere to the Single Responsibility Principle (SRP). This means a Node should be responsible for one specific task, such as:

-   Fetching data from a particular API endpoint.
-   Performing a specific database query (e.g., get user by ID).
-   Transforming data from one format to another.
-   Sending an email or notification.
-   Executing a complex calculation.
-   Interacting with a specific piece of hardware or external system.

This makes Nodes highly reusable, testable, and easier to understand and maintain.

### 2. TypeScript Class

In Nanoservice-ts, a Node is implemented as a TypeScript class that extends the `NanoService` base class provided by the `@nanoservice-ts/runner` package.

```typescript
// src/nodes/my-custom-node/index.ts
import { type INanoServiceResponse, NanoService, NanoServiceResponse } from "@nanoservice-ts/runner";
import { type Context, GlobalError } from "@nanoservice-ts/shared";

// Define types for expected input and output data
type InputType = { name: string; age: number };
type OutputType = { greeting: string; isAdult: boolean };

export default class MyCustomNode extends NanoService<InputType, OutputType> {
  constructor() {
    super();
    // Schemas are defined in the node's package.json
  }

  async handle(ctx: Context, inputs: InputType): Promise<INanoServiceResponse> {
    const response = new NanoServiceResponse();
    ctx.logger.info("MyCustomNode executed!", { inputs });

    try {
      // Your node's logic here
      const greeting = `Hello, ${inputs.name}!`;
      const isAdult = inputs.age >= 18;

      const output: OutputType = { greeting, isAdult };
      response.setSuccess(output);
      
    } catch (error: unknown) {
      const err = error as Error;
      ctx.logger.error("Error in MyCustomNode", { error: err.message });
      response.setError(new GlobalError(err.message, 500));
    }
    
    return response;
  }
}
```

### 3. The `handle` Method

The core logic of a Node resides in its `async handle(ctx: Context, inputs: InputType): Promise<INanoServiceResponse>` method.

-   **`ctx: Context`**: The context object provides access to shared resources and utilities, most notably the logger (`ctx.logger`). It can also carry information across workflow steps if using context manipulation nodes (though direct context mutation is generally discouraged for simple nodes).
-   **`inputs: InputType`**: This object contains the data passed to the Node from the Workflow. The structure of `inputs` is defined by the Node's `inputSchema`.
-   **`Promise<INanoServiceResponse>`**: The `handle` method must return a Promise that resolves to an `INanoServiceResponse` object. This object indicates the outcome of the Node's execution (success or failure) and carries the output data.
    -   `response.setSuccess(outputData)`: Call this to indicate successful execution and provide the output.
    -   `response.setError(globalErrorObject)`: Call this to indicate an error occurred.

### 4. Metadata and Schemas (`package.json`)

Each Node has an associated `package.json` file (located in its directory, e.g., `src/nodes/my-custom-node/package.json`). This file is crucial and contains:

-   **Basic Metadata:** `name`, `version`, `description`, `category`.
-   **`inputSchema`:** A JSON Schema definition for the expected input data (`InputType`). This schema is used for validation and can provide type hints in visual workflow builders.
-   **`outputSchema`:** A JSON Schema definition for the data the Node will produce upon successful execution (`OutputType`).
-   **`configurationSchema` (Optional):** If the node requires static configuration that is set once when the node is added to a workflow (and not per execution), it can be defined here.

**Example Node `package.json`:**

```json
{
  "name": "my-custom-node",
  "version": "1.0.0",
  "description": "A custom node that greets a user and checks if they are an adult.",
  "category": "Custom Utilities",
  "main": "index.js", // Entry point after build
  "types": "index.d.ts", // Type definitions after build
  "inputSchema": {
    "type": "object",
    "properties": {
      "name": {
        "type": "string",
        "description": "The name of the person to greet."
      },
      "age": {
        "type": "number",
        "description": "The age of the person."
      }
    },
    "required": ["name", "age"]
  },
  "outputSchema": {
    "type": "object",
    "properties": {
      "greeting": {
        "type": "string",
        "description": "The generated greeting message."
      },
      "isAdult": {
        "type": "boolean",
        "description": "Indicates if the person is an adult (age >= 18)."
      }
    },
    "required": ["greeting", "isAdult"]
  }
}
```

### 5. Registration (`src/Nodes.ts`)

For the Nanoservice-ts runtime to discover and use your custom Nodes, they must be registered in the `src/Nodes.ts` file in your project.

```typescript
// src/Nodes.ts
import type { NodeBase } from "@nanoservice-ts/shared";
import MyCustomNode from "./nodes/my-custom-node"; // Import your node class
import AnotherNode from "./nodes/another-node";

const nodes: { [key: string]: NodeBase; } = {
  // The key is the name used to reference the node in workflow definitions
  "my-custom-node": new MyCustomNode(), 
  "another-node": new AnotherNode(),
};

export default nodes;
```

The key used in the `nodes` object (e.g., `"my-custom-node"`) is how you will refer to this Node in your Workflow JSON definitions.

## Generating Nodes with `nanoctl`

The Nanoservice-ts CLI (`nanoctl`) simplifies the creation of new Nodes:

```bash
# Navigate to your project root
cd my-nanoservice-project

# Run the node creation command (using npx for latest version)
npx nanoctl@latest create node
```

The CLI will prompt you for:

-   Node name (e.g., `user-details-fetcher`)
-   Description
-   Category

It will then scaffold the Node directory (`src/nodes/user-details-fetcher/`), including the `index.ts` (with a basic template) and `package.json` (with placeholder schemas).

## Node Lifecycle (Simplified)

1.  **Registration:** At application startup, Nodes listed in `src/Nodes.ts` are registered with the runtime.
2.  **Workflow Execution:** When a Workflow containing a Node step is triggered:
    a.  The runtime identifies the required Node based on the name in the workflow definition.
    b.  An instance of the Node class is used (Nanoservice-ts typically instantiates nodes once at startup, as seen in `src/Nodes.ts`).
    c.  Input data (from the workflow, based on `{{...}}` templating) is prepared.
    d.  The `inputSchema` (if defined) is used to validate the input data before the `handle` method is called. If validation fails, the Node execution may error out before `handle` is invoked.
    e.  The Nodeâ€™s `async handle(ctx, inputs)` method is called.
    f.  The Node performs its logic.
    g.  The `handle` method returns a `NanoServiceResponse` (success or error).
    h.  The `outputSchema` (if defined and execution was successful) can be used to validate the output data.
    i.  The Node's output (or error) is passed to the next step in the Workflow or used to determine the final workflow response.

## Best Practices for Node Development

-   **Keep them focused:** Adhere to the Single Responsibility Principle.
-   **Define clear schemas:** Use `inputSchema` and `outputSchema` to clearly define the Node's contract. This is vital for validation, documentation, and integration with visual tools.
-   **Handle errors gracefully:** Always use `try...catch` in your `handle` method and return meaningful errors using `response.setError()`.
-   **Use the logger:** Utilize `ctx.logger` for informative logging (info, debug, error, warn).
-   **Asynchronous operations:** Properly use `async/await` for any I/O-bound or time-consuming tasks to keep your Node non-blocking (see [Asynchronous Operations](./../techniques/asynchronous-operations.mdx)).
-   **Configuration:** Externalize configuration (API keys, URLs) using environment variables or workflow inputs rather than hardcoding them (see [Configuration](./configuration.mdx)).
-   **Testability:** Design Nodes to be easily testable in isolation. Mock dependencies and test the `handle` method with various inputs and edge cases.

Nodes are the workhorses of your Nanoservice-ts applications. By understanding their structure and following best practices, you can build a powerful and maintainable library of reusable components.
