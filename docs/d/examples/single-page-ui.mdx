---
title: Single Page UI
---

## Example: Returning a Single Page UI from a Workflow

This example demonstrates how a Nanoservice-TS workflow can return a simple HTML page or a basic user interface directly to the client. This can be useful for status pages, simple admin interfaces, or scenarios where a lightweight UI is needed without a full frontend framework.

We will achieve this using a specialized Node, let's call it `UI.RenderHtml`, which takes HTML content as input and sets the appropriate HTTP response headers (like `Content-Type: text/html`).

## Purpose

*   Showcase the ability of Nanoservice-TS to serve simple web content.
*   Illustrate the use of a Node designed for rendering HTML or UI components.
*   Demonstrate setting custom HTTP response headers.

## Prerequisites

*   A Nanoservice-TS project.
*   A Node capable of rendering HTML and setting HTTP response headers (e.g., `UI.RenderHtml` or `Http.SetResponse` with HTML content and header capabilities).

## Node(s) Used (Conceptual)

1.  **`UI.RenderHtml` (or `Http.SetResponse` adapted for HTML)**:
    *   **Input Schema (Conceptual for `UI.RenderHtml`)**:
        *   `htmlContent` (string, required): The HTML string to be rendered.
        *   `statusCode` (number, optional, default: 200): The HTTP status code.
        *   `headers` (object, optional): Additional HTTP headers to set (e.g., `{"Content-Type": "text/html; charset=utf-8"}`).
    *   This node would internally handle setting the response body to `htmlContent` and ensuring the `Content-Type` header is `text/html`.

2.  **(Optional) `Utils.Logger`**: For logging.

## Workflow Definition (`simple-ui-example.json`)

Let's define a workflow triggered by an HTTP GET request to `/simple-ui` that returns a basic HTML page.

```json
{
  "name": "simpleUiPageWorkflow",
  "trigger": {
    "type": "Http",
    "config": {
      "path": "/simple-ui",
      "method": "GET"
    }
  },
  "nodes": [
    {
      "id": "1",
      "node": "Utils.Logger",
      "input": {
        "message": "Simple UI page workflow started."
      },
      "next_node_id": "2"
    },
    {
      "id": "2",
      "node": "UI.RenderHtml", // Assuming this node handles HTML rendering
      "input": {
        "statusCode": 200,
        "htmlContent": "<!DOCTYPE html><html><head><title>Nanoservice UI</title><style>body { font-family: sans-serif; margin: 20px; background-color: #f0f0f0; } h1 { color: #333; } p { color: #555; }</style></head><body><h1>Hello from Nanoservice-TS!</h1><p>This page was rendered by a Nanoservice workflow.</p><p>Current time: " + new Date().toLocaleTimeString() + "</p><script>setTimeout(() => document.querySelector('p:last-child').textContent = 'Current time: ' + new Date().toLocaleTimeString() + ' (updated!)', 2000);</script></body></html>",
        "headers": {
          "Content-Type": "text/html; charset=utf-8"
        }
      }
    }
  ]
}
```

**Explanation:**

1.  **Trigger**: The workflow `simpleUiPageWorkflow` starts with a GET request to `/simple-ui`.
2.  **Node 1 (`Utils.Logger`)**: Logs a starting message.
3.  **Node 2 (`UI.RenderHtml`)**: This node is responsible for sending the HTML page.
    *   `statusCode: 200` sets the HTTP status.
    *   `htmlContent`: Contains the actual HTML string. For this example, it includes a title, some basic styling, a heading, a paragraph, and a small piece of JavaScript to update the time dynamically on the client side.
    *   `headers`: Explicitly sets the `Content-Type` to `text/html; charset=utf-8`, which is crucial for the browser to interpret the response correctly as an HTML page.

**Note on Dynamic Content in HTML:**
The HTML content in the example is mostly static. If you need to inject dynamic data from the workflow (e.g., from a previous node or the context) into the HTML, you would typically use a templating mechanism. This might involve:
*   A dedicated templating node (e.g., `Template.RenderString`) before the `UI.RenderHtml` node.
*   The `UI.RenderHtml` node itself having built-in templating capabilities, allowing you to use placeholders like `{{context.someData}}` within the `htmlContent` string.

For simplicity, this example uses a static HTML string with a bit of client-side JavaScript for a touch of dynamism.

## How to Run

1.  Save the JSON above as `simple-ui-example.json` in your project's `workflows/` directory.
2.  Ensure your Nanoservice-TS project has the `UI.RenderHtml` (or an equivalent `Http.SetResponse` capable of handling HTML) and `Utils.Logger` nodes.
3.  Start your Nanoservice-TS runner:
    ```bash
    npm run dev
    ```
4.  Open your web browser and navigate to `http://localhost:4000/simple-ui` (assuming your runner is on port 4000).

## Expected Outcome

*   **Browser**: You should see a simple HTML page rendered in your browser with the title "Nanoservice UI", a heading "Hello from Nanoservice-TS!", and a paragraph. The time displayed should initially be the server render time and then update via client-side JavaScript after 2 seconds.
*   **Console Log**: You should see the "Simple UI page workflow started." message in your Nanoservice-TS runner's console.

This example demonstrates that Nanoservice-TS isn't limited to just JSON APIs. It can also serve basic web content, which can be useful for a variety of simple UI needs directly from your backend workflows.
