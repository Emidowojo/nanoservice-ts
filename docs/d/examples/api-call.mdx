---
title: API Call
---

## Example: Making an External API Call

This example demonstrates how to create a Nanoservice-TS workflow that makes a GET request to an external public API, retrieves data, and then makes that data available, for instance, by logging it or returning it in an HTTP response if the workflow is HTTP-triggered.

We will use the [JSONPlaceholder API](https://jsonplaceholder.typicode.com/) for this example, specifically fetching a list of todos.

## Purpose

*   Showcase the use of a Node designed for making HTTP requests (e.g., a core `Http.Request` Node or a similar custom Node).
*   Illustrate how to configure the Node with a URL and method.
*   Demonstrate how to access and use the API response within the workflow.

## Prerequisites

*   A Nanoservice-TS project.
*   Access to the internet from the environment where Nanoservice-TS is running.

## Node(s) Used

We will primarily use two types of Nodes:

1.  **HTTP Request Node**: A Node capable of making HTTP requests. Let's assume Nanoservice-TS provides a core Node named `Http.Request`.
    *   **Input Schema (Conceptual)**:
        *   `url` (string, required): The URL to request.
        *   `method` (string, optional, default: "GET"): HTTP method (GET, POST, etc.).
        *   `headers` (object, optional): Request headers.
        *   `body` (any, optional): Request body for POST, PUT, etc.
    *   **Output Schema (Conceptual)**:
        *   `statusCode` (number): The HTTP status code of the response.
        *   `headers` (object): Response headers.
        *   `body` (any): The response body (often parsed if JSON).

2.  **Logger Node**: A Node to log information, like `Utils.Logger`.
    *   **Input Schema (Conceptual)**:
        *   `message` (string, required): The message to log.

3.  **(Optional) HTTP Response Node**: If we want to expose this via an HTTP trigger, a Node like `Http.SetResponse` to send the fetched data back to the client.

## Workflow Definition (`api-call-example.json`)

Let's define a workflow that is triggered by an HTTP GET request to `/fetch-todos`. It will then call the JSONPlaceholder API and log the title of the first todo item received.

```json
{
  "name": "fetchExternalTodos",
  "trigger": {
    "type": "Http",
    "config": {
      "path": "/fetch-todos",
      "method": "GET"
    }
  },
  "nodes": [
    {
      "id": "1",
      "node": "Utils.Logger",
      "input": {
        "message": "Starting workflow to fetch external todos."
      },
      "next_node_id": "2"
    },
    {
      "id": "2",
      "node": "Http.Request", // Assuming this is the name of the HTTP client node
      "input": {
        "url": "https://jsonplaceholder.typicode.com/todos?_limit=5", // Fetching 5 todos
        "method": "GET"
      },
      "next_node_id": "3"
    },
    {
      "id": "3",
      "node": "Utils.Logger",
      "input": {
        // Accessing the body of the response from node "2"
        // Assuming the body is an array and we log the title of the first item.
        // The exact path to the data (e.g., {{nodes.2.output.body[0].title}}) 
        // depends on how the Http.Request node structures its output in the context.
        "message": "First todo title: {{nodes.2.output.body[0].title}}"
      },
      "next_node_id": "4"
    },
    {
      "id": "4",
      "node": "Http.SetResponse", // To send the fetched data back to the client
      "input": {
        "statusCode": 200,
        // Returning the entire body received from the external API
        "body": "{{nodes.2.output.body}}" 
      }
    }
  ]
}

```

**Explanation:**

1.  **Trigger**: The workflow `fetchExternalTodos` starts when a GET request is made to `/fetch-todos`.
2.  **Node 1 (`Utils.Logger`)**: Logs a starting message.
3.  **Node 2 (`Http.Request`)**: This is the core of the example.
    *   It makes a GET request to `https://jsonplaceholder.typicode.com/todos?_limit=5`.
    *   The response (status code, headers, body) from this API call will be made available in the context, typically accessible via a path like `context.nodes.<node_id>.output` or `context.results.<node_id>`.
4.  **Node 3 (`Utils.Logger`)**: 
    *   Logs the title of the first todo item. 
    *   `{{nodes.2.output.body[0].title}}` is a templated string that attempts to access the `title` of the first object in the `body` array returned by Node "2". The exact syntax for accessing previous node outputs in the context (`{{nodes.node_id.output...}}`) can vary based on the Nanoservice-TS runtime and templating engine.
5.  **Node 4 (`Http.SetResponse`)**:
    *   Takes the entire body from the external API call (output of Node "2") and sends it as the response to the initial `/fetch-todos` request.

## How to Run

1.  Save the JSON above as `api-call-example.json` in your project's `workflows/` directory.
2.  Ensure your Nanoservice-TS project has the necessary `Http.Request`, `Utils.Logger`, and `Http.SetResponse` nodes (or their equivalents). These are often core nodes.
3.  Start your Nanoservice-TS runner:
    ```bash
    npm run dev
    # or
    # yarn dev
    ```
4.  Open your browser or use `curl` to access `http://localhost:4000/fetch-todos` (assuming your runner is on port 4000).

## Expected Outcome

*   **Console Log**: You should see logs in your Nanoservice-TS runner's console:
    *   "Starting workflow to fetch external todos."
    *   "First todo title: delectus aut autem" (or similar, depending on the API response).
*   **HTTP Response**: Your browser/curl should receive a JSON array of 5 todo items from JSONPlaceholder.

This example provides a basic template for interacting with external APIs. You can extend it by adding error handling (e.g., if the API call fails), data transformation nodes after the API call, or more complex logic based on the API response.
